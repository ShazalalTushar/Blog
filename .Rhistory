reticulate::repl_python()
reticulate::repl_python()
55+61
55+6152
-m pip install jupyter
reticulate::repl_python()
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
Cabi= pd.read_csv(r'D:\VT Class Resourse\2-1\Machine Learning\Data for Blog\201905-capitalbikeshare-tripdata.csv')
Cabi.head(5)
Cabi['Duration (minutes)']=Cabi['Duration']/60
Cabi.head(5)
mean_duration = Cabi['Duration (minutes)'].mean()
std_duration = Cabi['Duration (minutes)'].std()
print(mean_duration,std_duration)
counts, bin_edges = np.histogram(Cabi['Duration (minutes)'], bins=10,
density = True)
pdf = counts/(sum(counts))
print(pdf);
print(bin_edges);
cdf = np.cumsum(pdf)
plt.plot(bin_edges[1:],pdf);
plt.plot(bin_edges[1:], cdf)
Casual= Cabi[Cabi['Member type'] == 'Casual']
Member= Cabi[Cabi['Member type'] == 'Member']
C_counts, C_bin_edges = np.histogram(Casual['Duration (minutes)'], bins=10,
density = True)
C_pdf = C_counts/(sum(C_counts))
print(C_pdf);
print(C_bin_edges);
C_cdf = np.cumsum(C_pdf)
plt.plot(C_bin_edges[1:],C_pdf,label= 'Casual User PDF');
plt.plot(C_bin_edges[1:], C_cdf,label= 'Casual User CDF')
M_counts, M_bin_edges = np.histogram(Member['Duration (minutes)'], bins=10,
density = True)
M_pdf = M_counts/(sum(M_counts))
print(M_pdf);
print(M_bin_edges);
M_cdf = np.cumsum(M_pdf)
plt.plot(M_bin_edges[1:],M_pdf,label= 'Member PDF');
plt.plot(M_bin_edges[1:], M_cdf,label= 'Member CDF')
plt.legend()
reticulate::repl_python()
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn import datasets
# Load Iris dataset
iris = datasets.load_iris()
# Petal width and length
X = iris.data[:, 2:4]
# The range of k values to try
k_values = range(1, 11)
# Calculate inertia for each k value
inertia_values = []
for k in k_values:
kmeans = KMeans(n_clusters=k, random_state=42)
kmeans.fit(X)
inertia_values.append(kmeans.inertia_)
# Plot the inertia values
plt.figure(figsize=(10, 6))
plt.plot(k_values, inertia_values, marker='o', linestyle='-', color='b')
plt.xlabel('Number of Clusters (k)')
plt.ylabel('Inertia')
plt.title('Elbow Method for Optimal k')
plt.grid(True)
plt.show()
quit
reticulate::py_config()
reticulate::py_install("scikit-learn")
reticulate::repl_python()
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn import datasets
# Load Iris dataset
iris = datasets.load_iris()
# Petal width and length
X = iris.data[:, 2:4]
# The range of k values to try
k_values = range(1, 11)
# Calculate inertia for each k value
inertia_values = []
for k in k_values:
kmeans = KMeans(n_clusters=k, random_state=42)
kmeans.fit(X)
inertia_values.append(kmeans.inertia_)
# Plot the inertia values
plt.figure(figsize=(10, 6))
plt.plot(k_values, inertia_values, marker='o', linestyle='-', color='b')
plt.xlabel('Number of Clusters (k)')
plt.ylabel('Inertia')
plt.title('Elbow Method for Optimal k')
plt.grid(True)
plt.show()
quit
py_install("scikit-learn")
reticulate::py_config()
py_install("scikit-learn")
install.packages("reticulate")
library(reticulate)
py_install("scikit-learn")
install.packages("reticulate")
library(reticulate)
py_install("scikit-learn")
reticulate::repl_python()
!pip install scikit-learn
